package com.recalot.common.configuration;

import com.recalot.common.exceptions.BaseException;
import com.recalot.common.exceptions.MissingArgumentException;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Created by matthaeus.schmedding on 02.04.2015.
 */
public abstract class Configurable {

    protected HashMap<String, ConfigurationItem> configurationMap = new HashMap<>();

    public ConfigurationItem[] getConfiguration() {
        return configurationMap.values().toArray(new ConfigurationItem[configurationMap.size()]);
    }

    public void setConfiguration(List<ConfigurationItem> configuration) {
        configurationMap = new HashMap<>();
        if (configuration != null) {
            for (ConfigurationItem item : configuration) {
                configurationMap.put(item.getKey(), item);
            }
        }
    }

    public ConfigurationItem getConfiguration(String key) {
        return configurationMap.get(key);
    }

    public void setConfiguration(ConfigurationItem configuration) {
        configurationMap.put(configuration.getKey(), configuration);
    }

    public void checkConfiguration(Map<String, String> config) throws BaseException {
        checkConfiguration("", config);
    }

    public void checkConfiguration(String prefix, Map<String, String> config) throws BaseException {
        if (this.configurationMap != null && config != null) {
            for (ConfigurationItem item : this.configurationMap.values()) {
                if (item.getRequirement() == ConfigurationItem.ConfigurationItemRequirementType.Required && !config.containsKey(prefix + item.getKey())) {
                    throw new MissingArgumentException("The argument %s is missing.", prefix + item.getKey());
                }

                if (config.containsKey(prefix + item.getKey())) {
                    item.setValue(config.get(prefix + item.getKey()));
                }
            }
        }
    }

    public static void applyConfiguration(Object instance, Class c, ConfigurationItem[] config) throws Exception {

        for (ConfigurationItem item : config) {
            if (item.getValue() != null) {
                String methodName = item.getKey();

                methodName = adjustMethodName(methodName);
                System.out.println(methodName + ":" + item.getValue());
                switch (item.getType()) {
                    case Integer: {

                        Method m = getMethod(c, methodName, Integer.class);
                        if (m == null) m = getMethod(c, methodName, int.class);
                        if (m != null) {
                            m.invoke(instance, Integer.parseInt(item.getValue()));
                        }

                        break;
                    }
                    case Double: {
                        Method m = getMethod(c, methodName, Double.class);
                        if (m == null) m = getMethod(c, methodName, double.class);
                        if (m != null) {
                            m.invoke(instance, Double.parseDouble(item.getValue()));
                        }
                        break;
                    }
                    case Boolean: {
                        Method m = getMethod(c, methodName, Boolean.class);
                        if (m == null) m = getMethod(c, methodName, boolean.class);
                        if (m != null) {
                            m.invoke(instance, Boolean.parseBoolean(item.getValue()));
                        }
                        break;
                    }
                    case Options:
                    case String: {
                        Method m = getMethod(c, methodName, String.class);
                        if (m != null) {
                            m.invoke(instance, item.getValue());
                        }
                        break;
                    }
                }
            }
        }
    }


    protected static Method getMethod(Class c, String methodName, Class cl) {
        Method m = null;
        Class tempClass = c;
        while (tempClass != null && m == null) {
            try {
                m = tempClass.getMethod(methodName, cl);
            } catch (NoSuchMethodException e) {
                tempClass = tempClass.getSuperclass();
            }
        }

        return m;
    }

    private static String adjustMethodName(String methodName) {
        StringBuilder builder = new StringBuilder();
        builder.append("set");
        String[] split = methodName.split("-");

        for (String s : split) {
            builder.append(s.substring(0, 1).toUpperCase() + s.substring(1));
        }

        return builder.toString();
    }


}
